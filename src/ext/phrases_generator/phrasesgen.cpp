#include "phrasesgen.h"

// IThread implementation
void CPhrasesGenerator::RunThread(IThreadHandle* pHandle)
{
    // Save thread start time.
    auto startTime = std::chrono::high_resolution_clock::now();

    LoadLanguages();

    std::vector<std::string> languageNames;

    // Get only languages names from m_LanguageCodeNames.
    std::transform(
        m_LanguageCodeNames.begin(),
        m_LanguageCodeNames.end(),
        std::back_inserter(languageNames),
        [](const auto& pair) { return StringToUTF8(pair.first); }
    );

    std::cout << "Parsing " << languageNames.size() << " Languages" << std::endl;

    // Parse all languages.
    ParseGameLocalizationFiles(languageNames);

    // Generate phrases files.
    GeneratePhrasesFromParsedFiles();

    // Notify about generation end.
    std::cout
        << "Generated translations in \"sourcemod/translations/\" (in "
        << std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now() - startTime).count()
        << "ms)" << std::endl;
}

void CPhrasesGenerator::OnTerminate(IThreadHandle* pHandle, bool cancel)
{ 
    // Thread is no longer valid.
    m_pThread = nullptr;
}

// Private methods implementation
void CPhrasesGenerator::LoadWhitelist()
{
    std::string whitelistPath;
    whitelistPath.resize(PLATFORM_MAX_PATH);

    smutils->BuildPath(
        Path_SM,
        whitelistPath.data(),
        PLATFORM_MAX_PATH,
        "configs/slp_whitelist.txt"
    );

    std::cout << whitelistPath << std::endl;

    std::ifstream whitelist(whitelistPath);

    // Create whitelist file (and skip whitelist parsing) if not present.
    if (!whitelist)
    {
        std::ofstream { whitelistPath };
        return;
    }

    // Read file.
    std::string line;
    while (std::getline(whitelist, line))
    {
        // Skip empty lines and comments (# or //).
        if (line.empty() || line.front() == '#' || line.front() == '/')
            continue;

        // Add language to whitelist.
        m_LanguageWhitelist.push_back(std::move(line));
    }

    // Close file.
    whitelist.close();
}

void CPhrasesGenerator::LoadLanguages()
{
    LoadWhitelist();

    const char *languageCode, *language;
    auto count = translator->GetLanguageCount();

    // Iterate through all languages.
    for (auto currentLanguage = 0; currentLanguage < count; currentLanguage++)
    {
        // Get language code and name.
        if (!translator->GetLanguageInfo(currentLanguage, &languageCode, &language))
        {
            std::cout << "Couldn't 'GetLanguageInfo' for index " << currentLanguage << "." << std::endl;
            continue;
        }

        std::cout << "languageCode: " << languageCode << ", language: " << language << std::endl;

        // Check if language is whitelisted.
        if (!IsLanguageWhitelisted(std::string_view(language)))
        {
            std::cout << "Language \"" << language << "\" is not whitelisted" << std::endl;
            continue;
        }

        // Add language to whitelist.
        m_LanguageCodeNames[StringToWide(std::string(language))] = StringToWide(std::string(languageCode));
    }
}

bool CPhrasesGenerator::IsLanguageWhitelisted(std::string_view language)
{
    return \
        // If whitelist is empty, all languages are whitelisted
        m_LanguageWhitelist.empty() ||
        // Check if language is in whitelist.
        std::find(
            m_LanguageWhitelist.begin(),
            m_LanguageWhitelist.end(),
            language
        ) != std::end(m_LanguageWhitelist) ||
        // If it's english, it's always whitelisted. (main phrases file should always exits to load it to SM)
        language == "english";
}

void CPhrasesGenerator::GeneratePhrasesFromParsedFiles()
{
    // Get SourceMod base path:
    static std::filesystem::path translationsBasePath = smutils->GetSourceModPath();
    translationsBasePath /= "translations";

    for (auto const& [language, langTokens] : m_Languages)
    {
        std::wstring& languageCode = m_LanguageCodeNames[language];

        if (languageCode.empty())
        {
            std::wcout << L"Language \"" << language << L"\" has no code" << std::endl;
            continue;
        }

        // Create phrases file.
        std::ofstream phrasesFile(
            translationsBasePath / 
                StringToUTF8(language != L"english" ? languageCode : L"") /
                    "localization.phrases.txt"
        );

        if (phrasesFile.fail())
        {
            std::wcout << L"Failed to open " << language << L" phrases file." << std::endl;
            continue;
        }

        // Write phrases output stream.
        std::wstringstream output;
        output << L"// " << language << L" phrases file" L"\n"
                  L"// Generated by 'Source Localization Parser'" L"\n"
                  L"\n"
                  L"\"" L"Phrases" L"\"" L"\n"
                  L"{" L"\n";

        // Write phrases file content.
        for (auto const& [key, value] : langTokens)
        {
            output << L"\t" L"\"" << key << L"\"" L"\n"
                      L"\t" L"{" L"\n"
                      L"\t" L"\t" L"\"" << languageCode << L"\"" L"\t" L"\t" L"\"" << value << L"\"" L"\n"
                      L"\t" L"}" L"\n"
                      L"\n";
        }

        // Write phrases file footer.
        output << L"}" L"\n";

        phrasesFile << StringToUTF8(output.str());

        // Close file.
        phrasesFile.close();

        // Notify about phrases file generation.
        std::wcout << L"Generated " << langTokens.size() << L" " << language << L" phrases." << std::endl;
    }
}

// Public functions implementation
void CPhrasesGenerator::Generate()
{
    if (m_pThread != nullptr)
    {
        std::cout << "Operation in progress\n" << std::endl;
        return;
    }

    m_pThread = threader->MakeThread(this, NULL);
}

void CPhrasesGenerator::SDK_OnUnload()
{
    // check if thread is running.
    if (m_pThread != NULL)
    {
        // Wait for thread to terminate.
        m_pThread->WaitForThread();
    }
}