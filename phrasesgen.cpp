#include "phrasesgen.h"
#include "extension.h"

#include <cstdio>
#include <iomanip>

void CreateDirHierarchy(const char* pszPath)
{
	std::string path = std::filesystem::path(pszPath).parent_path();
	std::filesystem::create_directories(path);
}

const char* ConvertKeyToLowerCase(const char* pszIn)
{
	static char s_key[MAX_KEY_LENGTH];
	static const char* const pszLast = s_key + sizeof(s_key) - 1;

	char* pszOut = s_key;
	while (*pszIn != '\0' && pszOut != pszLast)
	{
		*(pszOut++) = (char)tolower(*(pszIn++));
	}

	*pszOut = '\0';
	return s_key;
}

void CPhrasesGenerator::SDK_OnUnload()
{
	if (m_pThread != NULL)
	{
		// We can't quit yet - notify a thread about unloading
		m_bReqTerm = true;
		m_pThread->WaitForThread();
		m_bReqTerm = false;
	}
}

ParseAction_t CPhrasesGenerator::State_EnteredSection(const char* pszKey)
{
	if (m_nSection == Section_None && strcasecmp(pszKey, "lang") == 0)
	{
		m_nSection = Section_Settings;
	}
	else if (m_nSection == Section_Settings && strcasecmp(pszKey, "tokens") == 0)
	{
		m_nSection = Section_Tokens;
	}

	return Parse_Continue;
}

ParseAction_t CPhrasesGenerator::State_KeyValue(const char* pszKey, const char* const pszValue)
{
	if (m_nSection != Section_Tokens)
	{
		return Parse_Continue;
	}

	// Ignore phrases in non-english files that contain original line
	if (!m_bEnglishFile && strncasecmp(pszKey, "[english]", 9) == 0)
	{
		return Parse_Continue;
	}

	// Convert key to lower case
	const char* pszFixedKey = ConvertKeyToLowerCase(pszKey);

	m_Out
		//<< "\t// Token: \"" << pszKey << "\"\n"
		<< "\t\"" << pszFixedKey << "\"\n"
		<< "\t{\n";

	const char* pch = pszValue;
	if (m_bEnglishFile)
	{
		// Look out for "%sN" and place #format replacements
		bool bHadFormat = false;
		
		while (*pch != '\0')
		{
			char ch = *(pch++);
			if (ch == '%' && *pch == 's' && isdigit(*(pch + 1)) != 0)
			{
				if (bHadFormat)
				{
					m_Out << ",{" << ":s}";
				}
				else
				{
					bHadFormat = true;
					m_Out << "\t\t\"#format\"\t\"{" << *(pch + 1) << ":s}";
				}

				pch += 2;
			}
		}

		if (bHadFormat)
		{
			m_Out << "\"\n";
		}

		pch = pszValue;
	}

	m_Out
		<< "\t\t\"" << m_pszLangCode << "\"\t\t\"";

	// Escape some special characters
	while (*pch != '\0')
	{
		char ch = *(pch++);
		if (ch == '\n')
		{
			m_Out << "\\n";
		}
		else if (ch == '\v')
		{
			m_Out << "\\v";
		}
		else if (ch == '\r')
		{
			m_Out << "\\r";
		}
		else if (ch == '\t')
		{
			m_Out << "\\t";
		}
		else if (ch == '\f')
		{
			m_Out << "\\f";
		}
		else if (ch == '"')
		{
			m_Out << "\\\"";
		}
		else if (ch == '%' && *pch == 's' && isdigit(*(pch + 1)) != 0)
		{
			m_Out << '{' << *(pch + 1) << '}';
			pch += 2;
		}
		else
		{
			m_Out << ch;
		}
	}
	
	m_Out << "\"\n"
		<< "\t}\n"
		<< "\n";

	m_nParsed++;
	return Parse_Continue;
}

void CPhrasesGenerator::State_Ended(bool halted, bool failed)
{
	META_CONPRINTF("\tParsed %u\n", m_nParsed);

	m_Out
		<< "\t// " << m_nParsed << " phrases\n";
}

void CPhrasesGenerator::RunThread(IThreadHandle* pHandle)
{
	m_tmBegin = std::chrono::high_resolution_clock::now();

	char szTempPath[PLATFORM_MAX_PATH];
	smutils->BuildPath(Path_SM, szTempPath, sizeof(szTempPath), "data/translation_api/phrases.tmp.txt");
	CreateDirHierarchy(szTempPath);

	const char *pszGameFolderName = g_pSM->GetGameFolderName();

	size_t count = translator->GetLanguageCount();
	for (size_t n = 0; n < count; n++)
	{
		const char* pszLanguage = NULL;
		if (!translator->GetLanguageInfo(n, &m_pszLangCode, &pszLanguage))
		{
			META_CONPRINTF("Couldn't 'GetLanguageInfo' for n = %d\n", n);
			continue;
		}

		m_bEnglishFile = strcasecmp(pszLanguage, "english") == 0;

		if (!m_bEnglishFile && !m_vecLangWhitelist.empty() && std::find(m_vecLangWhitelist.begin(), m_vecLangWhitelist.end(), pszLanguage) == m_vecLangWhitelist.end())
		{
			META_CONPRINTF("skipping %s (not in whitelist)\n", pszLanguage);
			continue;
		}

		META_CONPRINTF("Processing '%s' \"%s\"\n", m_pszLangCode, pszLanguage);

		m_nParsed = 0;
		m_nSection = Section_None;

		m_Out.open(szTempPath);
		if (!m_Out.is_open())
		{
			META_CONPRINTF("Unable to open temp file \"%s\"\n", szTempPath);
			break;
		}

		std::time_t now = std::time(NULL);

		m_Out
			<< "// Generated by LanguagePhrasesParser\n"
			<< "// " << std::put_time(std::localtime(&now), "%c %Z") << "\n"
			<< "\n"
			<< "\"Phrases\"\n"
			<< "{\n";

		ParseTokensFromFile(pszGameFolderName, pszLanguage);

		m_Out << "}\n";
		m_Out.close();

		if (m_bReqTerm)
		{
			// Remove temp file
			unlink(szTempPath);
			break;
		}

		if (m_nParsed == 0)
		{
			continue;
		}

		char szActualPath[PLATFORM_MAX_PATH];
		if (m_bEnglishFile)
		{
			smutils->BuildPath(Path_SM, szActualPath, sizeof(szActualPath), "translations/%s.phrases.txt", pszGameFolderName);
		}
		else
		{
			smutils->BuildPath(Path_SM, szActualPath, sizeof(szActualPath), "translations/%s/%s.phrases.txt", m_pszLangCode, pszGameFolderName);
			CreateDirHierarchy(szActualPath);
		}

		if (std::filesystem::exists(szActualPath))
		{
			unlink(szActualPath);
		}

		std::filesystem::rename(szTempPath, szActualPath);
	}
}

void CPhrasesGenerator::OnTerminate(IThreadHandle* pHandle, bool cancel)
{
	auto now = std::chrono::high_resolution_clock::now();
	META_CONPRINTF("Generated translations in \"sourcemod/translations/\" (%ums)\n", std::chrono::duration_cast<std::chrono::milliseconds>(now - m_tmBegin).count());

	m_pThread = NULL;
}

void CPhrasesGenerator::Generate()
{
	if (m_pThread != NULL)
	{
		META_CONPRINTF("Operation in progress\n");
		return;
	}

	if (g_pLanguageFileParser == NULL)
	{
		META_CONPRINTF("Requires langparser.ext\n");
		return;
	}

	m_pThread = threader->MakeThread(this, NULL);
}


void CPhrasesGenerator::ParseTokensFromFile(const char* pszLangFileBase, const char* pszLanguage)
{
	if (m_bReqTerm)
	{
		return;
	}

	char relativePath[PLATFORM_MAX_PATH];
	smutils->Format(relativePath, sizeof(relativePath), "resource/%s_%s.txt", pszLangFileBase, pszLanguage);

	m_Out << "\t// Input file: " << relativePath << "\n";

	char error[256];
	ParseError_t parseError = g_pLanguageFileParser->ParseFile(relativePath, this, error, sizeof(error));
	if (parseError != ParseError_None && parseError != ParseError_StreamOpen)
	{
		META_CONPRINTF("'%s': %s\n", relativePath, error);
	}
}

void CPhrasesGenerator::LoadWhitelist()
{
	char szWhitelistPath[PLATFORM_MAX_PATH];

	// Get path with SM.
	smutils->BuildPath(Path_SM, szWhitelistPath, sizeof(szWhitelistPath), "configs/LanguagePhrasesParser/whitelist.txt");

	// Creates the folder if it's missing.
	CreateDirHierarchy(szWhitelistPath);

	// Open file.
	std::ifstream ifsWhiteList(szWhitelistPath);
	if (!ifsWhiteList)
	{
		META_CONPRINTF("No Whitelist found\n");
		return;
	}

	std::string line;
	while (std::getline(ifsWhiteList, line))
	{
		if (line.size() > 0)
		{
			m_vecLangWhitelist.push_back(line);
		}
	}

	ifsWhiteList.close();
}
