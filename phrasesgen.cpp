#include "phrasesgen.h"
#include "extension.h"

#include <cstdio>
#include <iomanip>

void CreateDirHierarchy(const char* filePath)
{
	// Get path without file name.
	std::string path = std::filesystem::path(filePath).parent_path().string();

	// Create all directories for file path.
	std::filesystem::create_directories(path);
}

void CPhrasesGenerator::SDK_OnUnload()
{
	if (m_pThread != NULL)
	{
		// We can't quit yet - notify a thread about unloading
		m_bReqTerm = true;
		m_pThread->WaitForThread();
		m_bReqTerm = false;
	}
}

ParseAction_t CPhrasesGenerator::State_EnteredSection(const char* key)
{
	if (m_nSection == Section_None && strcasecmp(key, "lang") == 0)
	{
		m_nSection = Section_Settings;
	}
	else if (m_nSection == Section_Settings && strcasecmp(key, "tokens") == 0)
	{
		m_nSection = Section_Tokens;
	}

	return Parse_Continue;
}

ParseAction_t CPhrasesGenerator::State_KeyValue(const char* key, const char* const value)
{
	if (m_nSection != Section_Tokens)
	{
		return Parse_Continue;
	}

	// Ignore phrases in non-english files that contain original line
	if (!m_bEnglishFile && strncasecmp(key, "[english]", 9) == 0)
	{
		return Parse_Continue;
	}

	m_Out
		<< "\t\"" << key << "\"\n"
		<< "\t{\n";

	const char* pch = value;

	m_Out
		<< "\t\t\"" << m_pszLangCode << "\"\t\t\"";

	// Escape some special characters
	while (*pch != '\0')
	{
		switch (*pch)
		{
			case '\n': m_Out << "\\n"; break;
			case '\v': m_Out << "\\v"; break;
			case '\r': m_Out << "\\r"; break;
			case '\t': m_Out << "\\t"; break;
			case '\f': m_Out << "\\f"; break;
			case '"': m_Out << "\\\""; break;
			default: m_Out << *pch;
		}

		pch++;
	}
	
	m_Out << "\"\n"
		<< "\t}\n"
		<< "\n";

	m_nParsed++;
	return Parse_Continue;
}

void CPhrasesGenerator::State_Ended(bool halted, bool failed)
{
	META_CONPRINTF("\tParsed %u\n", m_nParsed);

	m_Out
		<< "\t// " << m_nParsed << " phrases\n";
}

void CPhrasesGenerator::RunThread(IThreadHandle* pHandle)
{
	// Save thread start time.
	m_tmBegin = std::chrono::high_resolution_clock::now();

	char tempPath[PLATFORM_MAX_PATH];
	
	// Build absolute path from relative SM path.
	smutils->BuildPath(Path_SM, tempPath, sizeof(tempPath), "data/translation_api/phrases.tmp.txt");

	// Create all non-existing directories in path.
	CreateDirHierarchy(tempPath);

	// Loop languages.
	const char* language;
	for (auto& lang : m_Languages)
	{
		// Get data from pair.
		m_pszLangCode = lang.first.c_str();
		language = lang.second.c_str();

		META_CONPRINTF("Processing '%s' \"%s\"\n", m_pszLangCode, language);

		m_nParsed = 0;
		m_nSection = Section_None;
		m_bEnglishFile = strcasecmp(language, "english") == 0;

		// Open temp file to write to.
		m_Out.open(tempPath);

		// Stop if the temp file couldn't be opened.
		if (!m_Out.is_open())
		{
			META_CONPRINTF("Unable to open temp file \"%s\"\n", tempPath);
			break;
		}

		std::time_t now = std::time(NULL);

		m_Out
			<< "// Generated by LanguagePhrasesParser\n"
			<< "// " << std::put_time(std::localtime(&now), "%c %Z") << "\n"
			<< "\n"
			<< "\"Phrases\"\n"
			<< "{\n";

		ParseTokensFromFile(language);

		m_Out << "}\n";
		m_Out.close();

		if (m_bReqTerm)
		{
			unlink(tempPath);
			break;
		}

		if (m_nParsed == 0)
		{
			continue;
		}

		char actualPath[PLATFORM_MAX_PATH];
		if (m_bEnglishFile)
		{
			smutils->BuildPath(Path_SM, actualPath, sizeof(actualPath), "translations/%s.phrases.txt", g_pszGameFolderName);
		}
		else
		{
			smutils->BuildPath(Path_SM, actualPath, sizeof(actualPath), "translations/%s/%s.phrases.txt", m_pszLangCode, g_pszGameFolderName);
			CreateDirHierarchy(actualPath);
		}

		if (std::filesystem::exists(actualPath))
		{
			unlink(actualPath);
		}

		std::filesystem::rename(tempPath, actualPath);
	}

	m_Languages.clear();
}

void CPhrasesGenerator::OnTerminate(IThreadHandle* pHandle, bool cancel)
{
	auto now = std::chrono::high_resolution_clock::now();
	META_CONPRINTF("Generated translations in \"sourcemod/translations/\" (%ums)\n", std::chrono::duration_cast<std::chrono::milliseconds>(now - m_tmBegin).count());

	m_pThread = NULL;
}

void CPhrasesGenerator::Generate()
{
	if (m_pThread != NULL)
	{
		META_CONPRINTF("Operation in progress\n");
		return;
	}

	if (g_pLanguageFileParser == NULL)
	{
		META_CONPRINTF("Requires langparser.ext\n");
		return;
	}

	const char* languageCode;
	const char* language;
	size_t count = translator->GetLanguageCount();
	for (size_t n = 0; n < count; n++)
	{
		if (!translator->GetLanguageInfo(n, &languageCode, &language))
		{
			META_CONPRINTF("Couldn't 'GetLanguageInfo' for n = %d\n", n);
			continue;
		}
			// Don't filter english. (main phrases file should always exits to load it to SM)
		if (strcasecmp(language, "english") == 0 ||
			// If the whitelist is empty, skip the search.
			m_vecLangWhitelist.empty() ||
			// Language is found in the whitelist, add it.
			std::find(m_vecLangWhitelist.begin(), m_vecLangWhitelist.end(), language) != m_vecLangWhitelist.end())
		{
			m_Languages.emplace_back(languageCode, language);
		}
		else
		{
			META_CONPRINTF("skipping %s (not in whitelist)\n", language);
		}
	}

	m_pThread = threader->MakeThread(this, NULL);
}


void CPhrasesGenerator::ParseTokensFromFile(const char* language)
{
	if (m_bReqTerm)
	{
		return;
	}

	char relative_path[PLATFORM_MAX_PATH];
	smutils->Format(relative_path, sizeof(relative_path), "resource/%s_%s.txt", g_pszGameFolderName, language);

	m_Out << "\t// Input file: " << relative_path << "\n";

	char error[256];
	ParseError_t parseError = g_pLanguageFileParser->ParseFile(relative_path, this, error, sizeof(error));
	if (parseError != ParseError_None && parseError != ParseError_StreamOpen)
	{
		META_CONPRINTF("'%s': %s\n", relative_path, error);
	}
}

void CPhrasesGenerator::LoadWhitelist()
{
	char whitelistPath[PLATFORM_MAX_PATH];

	// Get path with SM.
	smutils->BuildPath(Path_SM, whitelistPath, sizeof(whitelistPath), "configs/lpp_whitelist.txt");

	// Creates the folder if it's missing.
	CreateDirHierarchy(whitelistPath);

	// Open file.
	std::ifstream ifsWhiteList(whitelistPath);

	// Create file (and skip whitelist parsing) if not present.
	if (!ifsWhiteList)
	{
		std::ofstream { whitelistPath };
		return;
	}

	// Parse whitelist languages.
	std::string line;
	while (std::getline(ifsWhiteList, line))
	{
		if (line.size() > 0)
		{
			m_vecLangWhitelist.push_back(line);
		}
	}

	// Close file.
	ifsWhiteList.close();
}
